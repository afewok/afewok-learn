
第一章：MySQL架构与历史

架构设计：查询处理、系统任务、数据的存储/提取

逻辑架构：
第一层：连接管理与安全：连接处理(线程池连接管理)、授权认证（用户名、密码）、安全管理（SSL、sql执行权限）
第二层：优化与执行（服务器层）：查询解析（解析树）、分析、优化（顺序，索引）、缓存，内置函数（日期、数字、加密）、存储过程、触发器、视图
第三层：存储引擎：通过api通讯，屏蔽引擎和底层文件存储差异，提供几十个底层函数（开始一个事务，根据主键提取一行数据），除了InnoDB会解析外键，其他存储引擎都不会解析SQL，也不相互通信


hint 可以影响优化决策
explain 可以查看优化因素
优化器会根据api获取存储引擎的开销信息和统计信息
select语句解析前会先检查查询缓存，找到对应查询，就不会解析，优化和执行-

读写锁、共享锁，排他锁（写锁，阻塞读写）
锁粒度（表锁，行锁，间隙锁）
获取锁，检查锁，解除锁，释放锁
花费时间管理锁，而不是存取数据，会影响系统的性能
锁策略：锁的开销和数据的安全之间寻求平衡
锁粒度：锁定的数据量（分级：表锁（开销最小的策略），行锁（最大程度支持并发和最大锁开销））
锁管理：策略和粒度

表锁也可能有良好的性能（read local表锁支持某些类型的并发写操作）
写锁优先级大于读锁：写锁可以插入到锁队列中的读锁前面
存储引擎实现了表锁和行锁，服务器层只有表锁（alter table）

ACID：原子性（共同进退）、一致性（在事务开始之前和事务结束以后，数据库的完整性没有被破坏）、隔离性（隔离级别）、持久性
事务（内、间、外）隔离级别：未提交读、提交读/不可重复读（脏读）、重复读（不可重复读/update/delete）、串行（幻读/insert）

死锁发生，只能回滚其中一个事务，才能打破死锁。InnoDB死锁的解决方式，将持有最少行级排他锁的事务进行回滚
锁的行为和顺序与存储引擎相关（出现死锁有可能是数据冲突，也有可能是存储引擎实现）



